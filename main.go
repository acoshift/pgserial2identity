package main

import (
	"database/sql"
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/acoshift/pgsql"
	"github.com/lib/pq"
)

func main() {
	if len(os.Args) != 2 {
		help()
		os.Exit(1)
	}

	db, err := sql.Open("postgres", os.Args[1])
	if err != nil {
		log.Fatalf("can not open database; %v", err)
	}
	defer db.Close()

	seqs, err := getAllSequences(db)
	if err != nil {
		log.Fatalf("can not get all sequences; %v", err)
	}

	askForConfirm := true
	for _, seq := range seqs {
		if askForConfirm {
			fmt.Printf("Convert %s sequence to identity ? [yNa] ", seq)

			var a string
			fmt.Scanln(&a)
			a = strings.ToLower(strings.TrimSpace(a))
			switch a {
			default:
				continue
			case "a":
				askForConfirm = false
			case "y":
			}
		}

		fmt.Printf("Converting %s: ", seq)

		err := pgsql.RunInTx(db, nil, func(tx *sql.Tx) error {
			ref, err := seq.TableRef(tx)
			if err != nil {
				return fmt.Errorf("can not get table ref; %w", err)
			}

			lastValue, err := seq.LastValue(tx)
			if err != nil {
				return fmt.Errorf("can not get sequence last value; %w", err)
			}

			_, err = tx.Exec(fmt.Sprintf(
				`alter table %s alter column %s drop default`,
				ref, ref.QuoteColumn(),
			))
			if err != nil {
				return fmt.Errorf("can not drop column %s default; %w", ref.Column, err)
			}

			_, err = tx.Exec(fmt.Sprintf(
				`alter table %s alter column %s add generated by default as identity`,
				ref, ref.QuoteColumn(),
			))
			if err != nil {
				return fmt.Errorf("can not add column identity; %w", err)
			}

			_, err = tx.Exec(fmt.Sprintf(
				`alter table %s alter column %s restart with %d`,
				ref, ref.QuoteColumn(), lastValue+1,
			))
			if err != nil {
				return fmt.Errorf("can not restart column identity; %w", err)
			}

			_, err = tx.Exec(fmt.Sprintf(
				`drop sequence %s`,
				seq,
			))
			if err != nil {
				return fmt.Errorf("can not sequence; %w", err)
			}

			return nil
		})
		if err != nil {
			fmt.Printf("Failed (%v)\n", err)
			break
		}
		fmt.Printf("Success\n")
	}
}

func help() {
	fmt.Println("Usage: pgserial2identity <db_uri>")
}

type sequence struct {
	Schema string
	Name   string
}

func (seq sequence) String() string {
	return fmt.Sprintf("%s.%s", seq.Schema, seq.Name)
}

func (seq sequence) LastValue(tx *sql.Tx) (v int64, err error) {
	err = tx.QueryRow(fmt.Sprintf(
		`select last_value from %s`,
		seq,
	)).Scan(&v)
	return
}

func (seq sequence) TableRef(tx *sql.Tx) (*tableRef, error) {
	var ref tableRef
	def := fmt.Sprintf("nextval('%s'::regclass)", seq.Name)
	err := tx.QueryRow(`
		select table_schema, table_name, column_name
		from information_schema.columns
		where table_schema = $1 and column_default = $2
	`, seq.Schema, def).Scan(
		&ref.Schema, &ref.Name, &ref.Column,
	)
	if err != nil {
		return nil, err
	}
	return &ref, nil
}

type tableRef struct {
	Schema string
	Name   string
	Column string
}

func (ref tableRef) String() string {
	return fmt.Sprintf("%s.%s", ref.Schema, ref.Name)
}

func (ref tableRef) QuoteColumn() string {
	return pq.QuoteIdentifier(ref.Column)
}

func getAllSequences(db *sql.DB) ([]*sequence, error) {
	var list []*sequence
	err := pgsql.Iter(db, func(scan pgsql.Scanner) error {
		var seq sequence
		err := scan(&seq.Schema, &seq.Name)
		if err != nil {
			return err
		}
		list = append(list, &seq)
		return nil
	},
		// language=SQL
		`
			select sequence_schema, sequence_name
			from information_schema.sequences
			order by sequence_schema, sequence_name
		`,
	)
	if err != nil {
		return nil, err
	}
	return list, nil
}
